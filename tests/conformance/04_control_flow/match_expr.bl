@prelude(core)

// Conformance: match expressions

type Color = | Red | Green | Blue

fn describe(c: Color) -> String = {
  match c
    Red -> "red"
    Green -> "green"
    Blue -> "blue"
}

test "match enum red" = describe(Red) == "red"
test "match enum green" = describe(Green) == "green"
test "match enum blue" = describe(Blue) == "blue"

fn unwrap_default(opt: Option<Int>, default: Int) -> Int = {
  match opt
    Some(x) -> x
    None -> default
}

test "match option some" = unwrap_default(Some(42), 0) == 42
test "match option none" = unwrap_default(None, -1) == -1

fn to_string(x: Int) -> String = {
  match x
    _ -> "anything"
}

test "match wildcard" = to_string(99) == "anything"

// --- Literal patterns ---

fn describe_num(x: Int) -> String = {
  match x
    0 -> "zero"
    1 -> "one"
    _ -> "other"
}

test "match literal zero" = describe_num(0) == "zero"
test "match literal one" = describe_num(1) == "one"
test "match literal fallthrough" = describe_num(42) == "other"

// --- Tuple patterns ---

test "match tuple destructure" = {
  let pair = (3, 7)
  let (a, b) = pair
  a + b == 10
}

test "match tuple ignore second" = {
  let pair = (5, 9)
  let (a, _) = pair
  a == 5
}

