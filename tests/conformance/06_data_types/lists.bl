@prelude(core)

// Conformance: list types and operations
// Inspired by: OCaml List module tests, Haskell Data.List tests, Elm List tests

// --- Construction ---
test "empty list length" = List.length([]) == 0
test "singleton list" = List.length([1]) == 1
test "list literal length" = List.length([1, 2, 3]) == 3

// --- Access ---
test "list head some" = {
  let h = List.head([10, 20, 30])
  Option.unwrap_or(h, 0) == 10
}

test "list head empty" = Option.is_none(List.head([]))

test "list tail content" = {
  let t = List.tail([10, 20, 30])
  Option.unwrap_or(List.head(t), 0) == 20
}

// --- Map ---
test "map doubles sum" = {
  let doubled = List.map([1, 2, 3], |x| x * 2)
  List.fold(doubled, 0, |acc, x| acc + x) == 12
}

test "map preserves length" = {
  List.length(List.map([1, 2, 3, 4], |x| x * 100)) == 4
}

// --- Filter ---
test "filter selects evens" = {
  let evens = List.filter([1, 2, 3, 4, 5, 6], |x| x % 2 == 0)
  List.fold(evens, 0, |a, b| a + b) == 12
}

test "filter none pass" = {
  List.length(List.filter([1, 3, 5], |x| x % 2 == 0)) == 0
}

// --- Fold ---
test "fold sum" = List.fold([1, 2, 3, 4], 0, |acc, x| acc + x) == 10
test "fold product" = List.fold([1, 2, 3, 4], 1, |acc, x| acc * x) == 24

// --- Search ---
test "find existing" = Option.unwrap_or(List.find([1, 2, 3], |x| x == 2), 0) == 2
test "find missing" = Option.is_none(List.find([1, 2, 3], |x| x == 99))

// --- Combining ---
test "concat length" = List.length(List.concat([1, 2], [3, 4])) == 4

// --- Ordering ---
test "reverse first" = Option.unwrap_or(List.head(List.reverse([1, 2, 3])), 0) == 3
test "sort first" = Option.unwrap_or(List.head(List.sort([3, 1, 4, 1, 5])), 0) == 1
test "sort preserves length" = List.length(List.sort([3, 1, 4, 1, 5, 9])) == 6
