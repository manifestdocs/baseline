@prelude(core)

// Conformance: record update (spread syntax) through the JIT
// Verifies the UpdateRecord IR node and jit_update_record helper.

type Point = { x: Int, y: Int }

test "record update single field" = {
  let p = Point { x: 1, y: 2 }
  let p2 = { ..p, x: 10 }
  p2.x == 10 && p2.y == 2
}

test "record update all fields" = {
  let p = Point { x: 1, y: 2 }
  let p2 = { ..p, x: 10, y: 20 }
  p2.x == 10 && p2.y == 20
}

test "record update preserves original" = {
  let p = Point { x: 1, y: 2 }
  let p2 = { ..p, x: 99 }
  // Original should be unchanged (immutable values)
  p.x == 1 && p2.x == 99
}

test "record update with computed value" = {
  let p = Point { x: 3, y: 4 }
  let p2 = { ..p, x: p.x * 2 }
  p2.x == 6 && p2.y == 4
}

test "record update chained" = {
  let p = Point { x: 1, y: 2 }
  let p2 = { ..p, x: 10 }
  let p3 = { ..p2, y: 20 }
  p3.x == 10 && p3.y == 20
}

type Named = { name: String, value: Int }

test "record update with string field" = {
  let r = Named { name: "old", value: 1 }
  let r2 = { ..r, name: "new" }
  r2.name == "new" && r2.value == 1
}

// Record update in a function
fn move_right(p: Point, dx: Int) -> Point = { ..p, x: p.x + dx }

test "record update in function" = {
  let p = Point { x: 0, y: 5 }
  let p2 = move_right(p, 3)
  p2.x == 3 && p2.y == 5
}
