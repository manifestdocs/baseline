@prelude(server)

// Row.decode â€” type checker positive tests

type User = { id: Int, name: String, age: Int, active: Bool }
type Profile = { bio: Option<String>, score: Option<Int> }

// Row.decode with basic types
fn decode_user!(row: Row) -> {Console} User = {
  let user = Row.decode(row, User)
  Console.println!("ok")
  user
}

// query! + List.map + Row.decode is the idiomatic typed query pattern
fn fetch_users!() -> {Sqlite, Console} List<User> = {
  Sqlite.connect!(":memory:")
  let rows = Sqlite.query!("SELECT * FROM users", [])
  let users = List.map(rows, |row| Row.decode(row, User))
  Console.println!("ok")
  users
}

// query_one! + Option.map + Row.decode for optional single-row fetch
fn fetch_user!() -> {Sqlite, Console} Option<User> = {
  Sqlite.connect!(":memory:")
  let row = Sqlite.query_one!("SELECT * FROM users WHERE id = ?1", ["1"])
  let user = Option.map(row, |r| Row.decode(r, User))
  Console.println!("ok")
  user
}

// Row.decode with Option fields
fn decode_profile!(row: Row) -> {Console} Profile = {
  let profile = Row.decode(row, Profile)
  Console.println!("ok")
  profile
}

fn main!() -> {Sqlite, Console} () = {
  Console.println!("row_decode check passed")
}

// expect: row_decode check passed
