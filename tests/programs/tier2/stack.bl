@prelude(script)

// Tier 2: Stack data structure â€” lists as stack, pattern matching

// Stack is represented as a List<Int>
// push: prepend to front, pop: take from front

fn push(stack: List<Int>, val: Int) -> List<Int> = List.concat([val], stack)

fn pop(stack: List<Int>) -> (Int, List<Int>) = {
  let top = Option.unwrap(List.head(stack))
  let rest = List.tail(stack)
  (top, rest)
}

fn peek(stack: List<Int>) -> Int = Option.unwrap(List.head(stack))

fn is_empty(stack: List<Int>) -> Bool = List.length(stack) == 0

fn main!() -> {Console} () = {
  let s0 = []
  let s1 = push(s0, 10)
  let s2 = push(s1, 20)
  let s3 = push(s2, 30)
  Console.println!("stack: ${s3}")
  Console.println!("peek: ${peek(s3)}")
  Console.println!("size: ${List.length(s3)}")
  Console.println!("empty: ${is_empty(s0)}")
}
