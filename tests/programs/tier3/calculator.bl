@prelude(script)

// Tier 3: RPN Calculator — lists as stack, pattern matching, string processing

// RPN (Reverse Polish Notation) calculator using a list-based stack

eval_rpn_step : (List<Int>, String) -> List<Int>
eval_rpn_step = |stack, token| {
  if token == "+" then {
    let b = Option.unwrap(List.head(stack))
    let rest1 = List.tail(stack)
    let a = Option.unwrap(List.head(rest1))
    let rest2 = List.tail(rest1)
    List.concat([a + b], rest2)
  }
  else if token == "*" then {
    let b = Option.unwrap(List.head(stack))
    let rest1 = List.tail(stack)
    let a = Option.unwrap(List.head(rest1))
    let rest2 = List.tail(rest1)
    List.concat([a * b], rest2)
  }
  else if token == "-" then {
    let b = Option.unwrap(List.head(stack))
    let rest1 = List.tail(stack)
    let a = Option.unwrap(List.head(rest1))
    let rest2 = List.tail(rest1)
    List.concat([a - b], rest2)
  }
  else {
    // Assume numeric token — parse manually for known values
    if token == "1" then List.concat([1], stack)
    else if token == "2" then List.concat([2], stack)
    else if token == "3" then List.concat([3], stack)
    else if token == "4" then List.concat([4], stack)
    else if token == "5" then List.concat([5], stack)
    else List.concat([0], stack)
  }
}

eval_rpn : List<String> -> Int
eval_rpn = |tokens| {
  let final_stack = List.fold(tokens, [], |stack, token| eval_rpn_step(stack, token))
  Option.unwrap_or(List.head(final_stack), 0)
}

main! : () -> {Console} ()
main! = || {
  // 2 3 + => 5
  let e1 = ["2", "3", "+"]
  Console.println!("2 3 + = ${eval_rpn(e1)}")

  // 2 3 + 4 * => 20
  let e2 = ["2", "3", "+", "4", "*"]
  Console.println!("2 3 + 4 * = ${eval_rpn(e2)}")

  // 5 3 - => 2
  let e3 = ["5", "3", "-"]
  Console.println!("5 3 - = ${eval_rpn(e3)}")

  // 1 2 3 * + 4 + => 1 + 6 + 4 = 11
  let e4 = ["1", "2", "3", "*", "+", "4", "+"]
  Console.println!("1 2 3 * + 4 + = ${eval_rpn(e4)}")
}
