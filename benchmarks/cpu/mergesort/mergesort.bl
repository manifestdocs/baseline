@prelude(script)

// Mergesort on a list of integers (repeated to get measurable time)
// Tests: list allocation (split/merge creates many intermediate lists),
//        recursion, pattern matching
// Sorts 200 elements, iterated via for loop

fn take(xs: List<Int>, n: Int) -> List<Int> =
  if n <= 0 then []
  else match List.head(xs)
    None -> []
    Some(h) -> List.concat([h], take(List.tail(xs), n - 1))

fn drop(xs: List<Int>, n: Int) -> List<Int> =
  if n <= 0 then xs
  else drop(List.tail(xs), n - 1)

fn merge(xs: List<Int>, ys: List<Int>) -> List<Int> =
  match List.head(xs)
    None -> ys
    Some(x) -> match List.head(ys)
      None -> xs
      Some(y) ->
        if x <= y then List.concat([x], merge(List.tail(xs), ys))
        else List.concat([y], merge(xs, List.tail(ys)))

fn msort(xs: List<Int>) -> List<Int> = {
  let n = List.length(xs)
  if n <= 1 then xs
  else {
    let mid = n / 2
    let left = msort(take(xs, mid))
    let right = msort(drop(xs, mid))
    merge(left, right)
  }
}

fn next_rand(seed: Int) -> Int = {
  let s = seed * 1103515245 + 12345
  let s = if s < 0 then 0 - s else s
  s % 1000000007
}

fn gen_list(n: Int, seed: Int, acc: List<Int>) -> List<Int> =
  if n <= 0 then acc
  else {
    let s = next_rand(seed)
    gen_list(n - 1, s, List.concat(acc, [s % 10000]))
  }

fn first_elem(xs: List<Int>) -> Int =
  match List.head(xs)
    Some(v) -> v
    None -> 0

fn main!() -> {Console} () = {
  let data = gen_list(200, 42, [])
  // Use fold over range to iterate without growing call stack
  let result = List.fold(1..201, 0, |acc, _| first_elem(msort(data)))
  Console.println!("${result}")
}
