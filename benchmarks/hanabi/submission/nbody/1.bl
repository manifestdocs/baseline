@prelude(script)

// N-Body benchmark — hanabi1224/Programming-Language-Benchmarks
// Solar system simulation: advance N steps, compute energy.
// Optimized: 5 individual bodies instead of List to eliminate heap allocations.

// Constants
fn pi() -> Float = 3.141592653589793
fn solar_mass() -> Float = 4.0 * pi() * pi()
fn days_per_year() -> Float = 365.24

// Body: x y z vx vy vz mass
type Body = { x: Float, y: Float, z: Float, vx: Float, vy: Float, vz: Float, mass: Float }

fn sun() -> Body = Body {
  x: 0.0, y: 0.0, z: 0.0,
  vx: 0.0, vy: 0.0, vz: 0.0,
  mass: solar_mass()
}

fn jupiter() -> Body = Body {
  x: 4.84143144246472090,
  y: 0.0 - 1.16032004402742839,
  z: 0.0 - 1.03622044471123109e-1,
  vx: 1.66007664274403694e-3 * days_per_year(),
  vy: 7.69901118419740425e-3 * days_per_year(),
  vz: 0.0 - 6.90460016972063023e-5 * days_per_year(),
  mass: 9.54791938424326609e-4 * solar_mass()
}

fn saturn() -> Body = Body {
  x: 8.34336671824457987,
  y: 4.12479856412430479,
  z: 0.0 - 4.03523417114321381e-1,
  vx: 0.0 - 2.76742510726862411e-3 * days_per_year(),
  vy: 4.99852801234917238e-3 * days_per_year(),
  vz: 2.30417297573763929e-5 * days_per_year(),
  mass: 2.85885980666130812e-4 * solar_mass()
}

fn uranus() -> Body = Body {
  x: 1.28943695621391310e1,
  y: 0.0 - 1.51111514016986312e1,
  z: 0.0 - 2.23307578892655734e-1,
  vx: 2.96460137564761618e-3 * days_per_year(),
  vy: 2.37847173959480950e-3 * days_per_year(),
  vz: 0.0 - 2.96589568540237556e-5 * days_per_year(),
  mass: 4.36624404335156298e-5 * solar_mass()
}

fn neptune() -> Body = Body {
  x: 1.53796971148509165e1,
  y: 0.0 - 2.59193146099879641e1,
  z: 1.79258772950371181e-1,
  vx: 2.68067772490389322e-3 * days_per_year(),
  vy: 1.62824170038242295e-3 * days_per_year(),
  vz: 0.0 - 9.51592254519715870e-5 * days_per_year(),
  mass: 5.15138902046611451e-5 * solar_mass()
}

// Apply gravitational force between a pair of bodies
fn apply_pair(bi: Body, bj: Body, dt: Float) -> (Body, Body) = {
  let dx = bi.x - bj.x
  let dy = bi.y - bj.y
  let dz = bi.z - bj.z
  let dist2 = dx * dx + dy * dy + dz * dz
  let dist = Math.sqrt(dist2)
  let mag = dt / (dist2 * dist)
  let ni = { ..bi,
    vx: bi.vx - dx * bj.mass * mag,
    vy: bi.vy - dy * bj.mass * mag,
    vz: bi.vz - dz * bj.mass * mag
  }
  let nj = { ..bj,
    vx: bj.vx + dx * bi.mass * mag,
    vy: bj.vy + dy * bi.mass * mag,
    vz: bj.vz + dz * bi.mass * mag
  }
  (ni, nj)
}

// Update position from velocity
fn move_body(b: Body, dt: Float) -> Body =
  { ..b, x: b.x + dt * b.vx, y: b.y + dt * b.vy, z: b.z + dt * b.vz }

// Advance simulation by dt — unrolled for 5 bodies, 10 pairs
fn advance(b0: Body, b1: Body, b2: Body, b3: Body, b4: Body, dt: Float) -> (Body, Body, Body, Body, Body) = {
  // pair (0,1)
  let r = apply_pair(b0, b1, dt)
  let b0 = match r
    (a, _) -> a
  let b1 = match r
    (_, a) -> a
  // pair (0,2)
  let r = apply_pair(b0, b2, dt)
  let b0 = match r
    (a, _) -> a
  let b2 = match r
    (_, a) -> a
  // pair (0,3)
  let r = apply_pair(b0, b3, dt)
  let b0 = match r
    (a, _) -> a
  let b3 = match r
    (_, a) -> a
  // pair (0,4)
  let r = apply_pair(b0, b4, dt)
  let b0 = match r
    (a, _) -> a
  let b4 = match r
    (_, a) -> a
  // pair (1,2)
  let r = apply_pair(b1, b2, dt)
  let b1 = match r
    (a, _) -> a
  let b2 = match r
    (_, a) -> a
  // pair (1,3)
  let r = apply_pair(b1, b3, dt)
  let b1 = match r
    (a, _) -> a
  let b3 = match r
    (_, a) -> a
  // pair (1,4)
  let r = apply_pair(b1, b4, dt)
  let b1 = match r
    (a, _) -> a
  let b4 = match r
    (_, a) -> a
  // pair (2,3)
  let r = apply_pair(b2, b3, dt)
  let b2 = match r
    (a, _) -> a
  let b3 = match r
    (_, a) -> a
  // pair (2,4)
  let r = apply_pair(b2, b4, dt)
  let b2 = match r
    (a, _) -> a
  let b4 = match r
    (_, a) -> a
  // pair (3,4)
  let r = apply_pair(b3, b4, dt)
  let b3 = match r
    (a, _) -> a
  let b4 = match r
    (_, a) -> a
  // move all bodies
  let b0 = move_body(b0, dt)
  let b1 = move_body(b1, dt)
  let b2 = move_body(b2, dt)
  let b3 = move_body(b3, dt)
  let b4 = move_body(b4, dt)
  (b0, b1, b2, b3, b4)
}

// Advance taking/returning a state tuple
fn advance_s(s: (Body, Body, Body, Body, Body), dt: Float) -> (Body, Body, Body, Body, Body) = {
  let b0 = match s
    (a, _, _, _, _) -> a
  let b1 = match s
    (_, a, _, _, _) -> a
  let b2 = match s
    (_, _, a, _, _) -> a
  let b3 = match s
    (_, _, _, a, _) -> a
  let b4 = match s
    (_, _, _, _, a) -> a
  let next = advance(b0, b1, b2, b3, b4, dt)
  next
}

// Tail-recursive step loop (tuple in/out for true tail call)
fn run_steps(s: (Body, Body, Body, Body, Body), n: Int, dt: Float) -> (Body, Body, Body, Body, Body) =
  if n <= 0 then s
  else run_steps(advance_s(s, dt), n - 1, dt)

// Offset momentum so total system momentum is zero
fn offset_momentum(b0: Body, b1: Body, b2: Body, b3: Body, b4: Body) -> (Body, Body, Body, Body, Body) = {
  let px = b0.vx * b0.mass + b1.vx * b1.mass + b2.vx * b2.mass + b3.vx * b3.mass + b4.vx * b4.mass
  let py = b0.vy * b0.mass + b1.vy * b1.mass + b2.vy * b2.mass + b3.vy * b3.mass + b4.vy * b4.mass
  let pz = b0.vz * b0.mass + b1.vz * b1.mass + b2.vz * b2.mass + b3.vz * b3.mass + b4.vz * b4.mass
  let sm = solar_mass()
  let b0 = { ..b0, vx: 0.0 - px / sm, vy: 0.0 - py / sm, vz: 0.0 - pz / sm }
  (b0, b1, b2, b3, b4)
}

// Potential energy between two bodies
fn pe(bi: Body, bj: Body) -> Float = {
  let dx = bi.x - bj.x
  let dy = bi.y - bj.y
  let dz = bi.z - bj.z
  let dist = Math.sqrt(dx * dx + dy * dy + dz * dz)
  0.0 - bi.mass * bj.mass / dist
}

// Kinetic energy of one body
fn ke(b: Body) -> Float =
  0.5 * b.mass * (b.vx * b.vx + b.vy * b.vy + b.vz * b.vz)

// Total system energy — unrolled (let-bound to avoid nested call VM bug)
fn energy(b0: Body, b1: Body, b2: Body, b3: Body, b4: Body) -> Float = {
  ke(b0) + ke(b1) + ke(b2) + ke(b3) + ke(b4) + pe(b0, b1) + pe(b0, b2) + pe(b0, b3) + pe(b0, b4) + pe(b1, b2) + pe(b1, b3) + pe(b1, b4) + pe(b2, b3) + pe(b2, b4) + pe(b3, b4)
}

// Main
fn main!() -> () = {
  let args = Env.args!()
  let n_str = Option.unwrap_or(List.get(args, 0), "1000")
  let n = match Int.parse(n_str)
    Ok(v) -> v
    Err(_) -> 1000

  let b0 = sun()
  let b1 = jupiter()
  let b2 = saturn()
  let b3 = uranus()
  let b4 = neptune()

  let r = offset_momentum(b0, b1, b2, b3, b4)
  let b0 = match r
    (a, _, _, _, _) -> a
  let b1 = match r
    (_, a, _, _, _) -> a
  let b2 = match r
    (_, _, a, _, _) -> a
  let b3 = match r
    (_, _, _, a, _) -> a
  let b4 = match r
    (_, _, _, _, a) -> a

  let _ = Console.println!(Float.format(energy(b0, b1, b2, b3, b4), 9))

  let s = (b0, b1, b2, b3, b4)
  let r = run_steps(s, n, 0.01)
  let b0 = match r
    (a, _, _, _, _) -> a
  let b1 = match r
    (_, a, _, _, _) -> a
  let b2 = match r
    (_, _, a, _, _) -> a
  let b3 = match r
    (_, _, _, a, _) -> a
  let b4 = match r
    (_, _, _, _, a) -> a

  let _ = Console.println!(Float.format(energy(b0, b1, b2, b3, b4), 9))
}
