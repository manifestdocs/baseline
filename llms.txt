# Baseline Language Quick Reference

> Baseline: strongly typed, effect-tracked functional language. Extension: `.bl`, compiler: `blc`.

## Syntax

### Functions
```
fn add(a: Int, b: Int) -> Int = a + b
fn effectful!(x: Int) -> {Console} () = Console.println!("${x}")
```

### Effects
Effectful functions end with `!` and declare effects in `{...}`:
```
fn fetch!(url: String) -> {Http, Log} Result<String, String> = {
  Log.info!("Fetching ${url}")
  Http.get!(url)
}
```
Pure functions (no `!`) cannot call effectful functions.

### Types
```
type Port = Int where self > 0 && self <= 65535    // Refinement type
type Status = | Active | Inactive | Error(String)  // Sum type (enum)
type User = { name: String, age: Int }             // Record type
type UserId = Int                                  // Type alias
type HasName = { name: String, ..r }               // Open record (row polymorphism)
```

### Built-in Types
`Int`, `String`, `Bool`, `Float`, `Unit`, `List<T>`, `Option<T>`, `Result<T, E>`

### Let Bindings
```
let x = 42
let name: String = "Alice"
```

### Conditionals
```
if condition then expr1 else expr2
```

### Pattern Matching (exhaustive)
```
match value
  Some(x) -> x
  None -> 0

match status
  Active -> "active"
  Inactive -> "inactive"
  Error(msg) -> "error: ${msg}"
```

### Pipes and Lambdas
```
value |> transform |> validate    // |> inserts left as first arg
|x| x + 1                         // Lambda
|a, b| a + b
```

### Lists
```
let nums = [1, 2, 3]
List.map(nums, |x| x * 2)
List.filter(nums, |x| x > 1)
List.fold(nums, 0, |acc, x| acc + x)
```

### Records
```
let user = User { name: "Alice", age: 30 }
user.name                              // Field access
{ ..user, age: 31 }                   // Record update
```

### Row Polymorphism
```
fn greet(person: { name: String, ..r }) -> String = person.name
greet({ name: "Alice", age: 30 })      // OK — extra fields absorbed by ..r
greet({ name: "Bob" })                 // OK — exact match
```

### String Interpolation
```
"Hello, ${name}. You are ${age} years old."
```

### Error Handling
```
// Result: Ok(value) or Err(error)
let user = get_user(id)?               // Propagate with ?
match get_user(id)
  Ok(u) -> process(u)
  Err(e) -> handle(e)

// Option: Some(value) or None (sugar: T? means Option<T>)
```

### Inline Tests
```
fn add(a: Int, b: Int) -> Int = a + b

@test
test "basic" = add(1, 2) == 3
test "zero" = add(0, 5) == 5
```

### Modules
```
@prelude(script)                   // Prelude: core, pure, script, server
import Math                        // Qualified: Math.sqrt(9)
import Math { sqrt, pow }          // Selective
import Math *                      // Wildcard
```

### Logical Operators
`&&`, `||`, `not` (keyword, not `!`)

## Key Rules

1. Pure functions have NO `!` suffix and CANNOT use effects
2. Effectful functions end with `!` and declare effects: `-> {Http, Fs} Result<T, E>`
3. Effects are called with `!`: `Console.println!("hello")`
4. Pattern matching must be exhaustive
5. `not` is a keyword for logical negation (not `!`)
6. String interpolation uses `${expr}`
7. Pipe `|>` inserts left value as first argument to right function

## NOT Supported

- No `class`/`extends`/`implements` — use records + sum types + effects
- No `try`/`catch`/`throw` — use `Result<T, E>` with `?`
- No `null`/`undefined`/`nil` — use `Option<T>`
- No `async`/`await` — effects handle this
- No `+` for string concat — use `"${a}${b}"`
- No `!` for boolean negation — use `not`
- No `value.method()` — use `Module.method(value)`
- No mutable variables, no `return` keyword, no semicolons
- No backward pipe `<|` or composition `>>`, `<<`

## Common Patterns

```
// Effectful entry point
fn main!() -> {Console} () =
  Console.println!("Hello, Baseline!")

// Data transformation
fn process(items: List<Int>) -> List<Int> = {
  let positive = List.filter(items, |x| x > 0)
  List.map(positive, |x| x * 2)
}

// Error propagation
fn safe_divide(a: Int, b: Int) -> Result<Int, String> =
  if b == 0 then Err("Division by zero") else Ok(a / b)

// Sum type with pattern matching
type Shape = | Circle(Float) | Rectangle(Float, Float)

fn area(s: Shape) -> Float =
  match s
    Circle(r) -> 3.14159 * r * r
    Rectangle(w, h) -> w * h
```

## HTTP Server

```
@prelude(server)

fn health(req: { method: String }) -> {Http} Result<{ status: Int, headers: List<(String, String)>, body: String }, String> =
  Ok(Response.ok("healthy"))

fn main!() -> {Http} () =
  Router.new()
    |> Router.get("/health", health)
    |> Server.listen!(8080)
```
## Preludes

| Level | Use Case | Includes |
|-------|----------|---------|
| `core` | Pure computation | Types, Option, Result |
| `pure` | Data processing | + String, List, Int, Math |
| `script` | CLI scripting | + Console, Env, Fs |
| `server` | HTTP services | + Http, Response, Router, Server |

## Compiler
```
blc check file.bl           # Type/effect check
blc check file.bl --json    # JSON diagnostics
blc run file.bl             # Compile and run (VM)
blc test file.bl            # Run inline tests
blc test file.bl --json     # JSON test output
blc fmt file.bl             # Format source
```