# Baseline Language Quick Reference

> Baseline: strongly typed, effect-tracked functional language. Extension: `.bl`, compiler: `blc`.

## Rosetta Stone (Python → Baseline)

### Variable Declaration
Python:    `x = 10`
Baseline:  `let x = 10`

### Function Definition
Python:    `def add(a: int, b: int) -> int: return a + b`
Baseline:  `fn add(a: Int, b: Int) -> Int = a + b`

### Side Effects (Print)
Python:    `print("hello")`
Baseline:  `Console.println!("hello")`

### List Operations
Python:    `[x * 2 for x in items if x > 0]`
Baseline:  `items |> List.filter(|x| x > 0) |> List.map(|x| x * 2)`

### Error Handling
Python:    `try: val = risky() / except: val = default`
Baseline:  `match risky() { Ok(v) -> v, Err(_) -> default }`

### Null Handling
Python:    `if x is not None: use(x)`
Baseline:  `match x { Some(v) -> use(v), None -> fallback }`

### String Concatenation
Python:    `greeting = "Hello, " + name + "!"`
Baseline:  `let greeting = "Hello, ${name}!"`

### Classes → Records + Sum Types
Python:    `class User: def __init__(self, name, age): ...`
Baseline:  `type User = { name: String, age: Int }`

### Method Calls
Python:    `name.upper()`
Baseline:  `String.to_upper(name)`

### Boolean Negation
Python:    `if not valid:`
Baseline:  `if not valid then ...`

### HTTP Handler
Python:    `@app.get("/health") / def health(): return "ok"`
Baseline:  `fn health(req: {...}) -> Result<{...}, String> = Ok(Response.ok("healthy"))`

### Lambda / Anonymous Function
Python:    `lambda x: x + 1`
Baseline:  `|x| x + 1`

## Syntax

### Functions
```
fn add(a: Int, b: Int) -> Int = a + b
fn effectful!(x: Int) -> () = Console.println!("${x}")
```

### Effects
Effectful functions end with `!`. Effect annotations are optional — the compiler infers them:
```
fn fetch!(url: String) -> Result<String, String> = {
  Log.info!("Fetching ${url}")
  Http.get!(url)
}
```
Explicit annotations are allowed for documentation or to restrict effects:
```
fn fetch!(url: String) -> {Http, Log} Result<String, String> = ...
```
Pure functions (no `!`) cannot call effectful functions.

### Types
```
type Port = Int where self > 0 && self <= 65535    // Refinement type
type Status = | Active | Inactive | Error(String)  // Sum type (enum)
type User = { name: String, age: Int }             // Record type
type UserId = Int                                  // Type alias
type HasName = { name: String, ..r }               // Open record (row polymorphism)
```

### Built-in Types
`Int`, `String`, `Bool`, `Float`, `Unit`, `List<T>`, `Option<T>`, `Result<T, E>`

### Let Bindings
```
let x = 42
let name: String = "Alice"
```

### Conditionals
```
if condition then expr1 else expr2
```

### Pattern Matching (exhaustive)
```
match value
  Some(x) -> x
  None -> 0

match status
  Active -> "active"
  Inactive -> "inactive"
  Error(msg) -> "error: ${msg}"
```

### Pipes and Lambdas
```
value |> transform |> validate    // |> inserts left as first arg
|x| x + 1                         // Lambda
|a, b| a + b
```

### Lists
```
let nums = [1, 2, 3]
List.map(nums, |x| x * 2)
List.filter(nums, |x| x > 1)
List.fold(nums, 0, |acc, x| acc + x)
```

### Records
```
let user = User { name: "Alice", age: 30 }
user.name                              // Field access
{ ..user, age: 31 }                   // Record update
```

### Row Polymorphism
```
fn greet(person: { name: String, ..r }) -> String = person.name
greet({ name: "Alice", age: 30 })      // OK — extra fields absorbed by ..r
greet({ name: "Bob" })                 // OK — exact match
```

### String Interpolation
```
"Hello, ${name}. You are ${age} years old."
```

### Error Handling
```
// Result: Ok(value) or Err(error)
let user = get_user(id)?               // Propagate with ?
match get_user(id)
  Ok(u) -> process(u)
  Err(e) -> handle(e)

// Option: Some(value) or None (sugar: T? means Option<T>)
```

### Inline Tests
```
fn add(a: Int, b: Int) -> Int = a + b

@test
test "basic" = add(1, 2) == 3
test "zero" = add(0, 5) == 5
```

### Modules
```
@prelude(script)                   // Prelude: core, pure, script, server
import Math                        // Qualified: Math.sqrt(9)
import Math { sqrt, pow }          // Selective
import Math *                      // Wildcard
```

### Logical Operators
`&&`, `||`, `not` (keyword, not `!`)

## Key Rules

1. Pure functions have NO `!` suffix and CANNOT use effects
2. Effectful functions end with `!` — effect annotations are optional (inferred by compiler)
3. Effects are called with `!`: `Console.println!("hello")`
4. Pattern matching must be exhaustive
5. `not` is a keyword for logical negation (not `!`)
6. String interpolation uses `${expr}`
7. Pipe `|>` inserts left value as first argument to right function

## NOT Supported

- No `class`/`extends`/`implements` — use records + sum types + effects
- No `try`/`catch`/`throw` — use `Result<T, E>` with `?`
- No `null`/`undefined`/`nil` — use `Option<T>`
- No `async`/`await` — effects handle this
- No `+` for string concat — use `"${a}${b}"`
- No `!` for boolean negation — use `not`
- No `value.method()` — use `Module.method(value)`
- No mutable variables, no `return` keyword, no semicolons
- No backward pipe `<|` or composition `>>`, `<<`

## Common Agent Mistakes

WRONG: `user.to_string()`   → RIGHT: `String.from(user)` — no method calls on values
WRONG: `!valid`             → RIGHT: `not valid` — `!` is for effects, `not` is for negation
WRONG: `"a" + "b"`          → RIGHT: `"${a}${b}"` — no `+` for string concatenation
WRONG: `return x`           → RIGHT: `x` — last expression is the return value
WRONG: `let mut x = 0`      → RIGHT: restructure with recursion or `List.fold`
WRONG: `try { risky() }`    → RIGHT: `match risky() { Ok(v) -> v, Err(e) -> handle(e) }`
WRONG: `async fn fetch()`   → RIGHT: `fn fetch!()` — effects replace async/await
WRONG: `x; y; z`            → RIGHT: `{ let _ = x  let _ = y  z }` — no semicolons
WRONG: `fn foo { ... }`     → RIGHT: `fn foo() -> Type = expr` — signature required
WRONG: `import { foo }`     → RIGHT: `import Foo { bar }` — module names are PascalCase

## Common Patterns

```
// Effectful entry point
fn main!() =
  Console.println!("Hello, Baseline!")

// Data transformation
fn process(items: List<Int>) -> List<Int> = {
  let positive = List.filter(items, |x| x > 0)
  List.map(positive, |x| x * 2)
}

// Error propagation
fn safe_divide(a: Int, b: Int) -> Result<Int, String> =
  if b == 0 then Err("Division by zero") else Ok(a / b)

// Sum type with pattern matching
type Shape = | Circle(Float) | Rectangle(Float, Float)

fn area(s: Shape) -> Float =
  match s
    Circle(r) -> 3.14159 * r * r
    Rectangle(w, h) -> w * h
```

## HTTP Server

```
@prelude(server)

fn health(req: { method: String }) -> Result<{ status: Int, headers: List<(String, String)>, body: String }, String> =
  Ok(Response.ok("healthy"))

fn main!() =
  Router.new()
    |> Router.get("/health", health)
    |> Server.listen!(8080)
```
## Preludes

| Level | Use Case | Includes |
|-------|----------|---------|
| `core` | Pure computation | Types, Option, Result |
| `pure` | Data processing | + String, List, Int, Math |
| `script` | CLI scripting | + Console, Env, Fs |
| `server` | HTTP services | + Http, Response, Router, Server |

## Compiler
```
blc check file.bl           # Type/effect check
blc check file.bl --json    # JSON diagnostics
blc run file.bl             # Compile and run (VM)
blc test file.bl            # Run inline tests
blc test file.bl --json     # JSON test output
blc fmt file.bl             # Format source
```