# Baseline v0.2

> Baseline is a strongly typed, effect-tracked functional programming language. Extension: `.bl`, compiler: `blc`. Design philosophy: "The type is the spec" (refinements encode correctness), "Effects are data" (side effects are explicit capabilities tracked by the compiler).

Important — LLMs commonly get these wrong:
- `!` means EFFECTS, not negation. Use `not` for boolean negation. `!valid` is a parse error.
- NO method syntax. Write `String.to_upper(name)`, never `name.to_upper()`.
- NO `+` for strings. Write `"Hello, ${name}!"`, never `"Hello, " + name`.
- NO semicolons. Statements are separated by newlines.
- NO `return` keyword. The last expression is the return value.
- All bindings are immutable. No `var`, no mutation, no reassignment.

## Rosetta Stone (Python -> Baseline)

### Variable Declaration
Python:    `x = 10`
Baseline:  `let x = 10`

### Function Definition
Python:    `def add(a: int, b: int) -> int: return a + b`
Baseline:  `fn add(a: Int, b: Int) -> Int = a + b`

### Side Effects (Print)
Python:    `print("hello")`
Baseline:  `Console.println!("hello")`

### List Operations
Python:    `[x * 2 for x in items if x > 0]`
Baseline:  `items |> List.filter(|x| x > 0) |> List.map(|x| x * 2)`

### Error Handling
Python:    `try: val = risky() / except: val = default`
Baseline:  `match risky() { Ok(v) -> v, Err(_) -> default }`

### Null Handling
Python:    `if x is not None: use(x)`
Baseline:  `match x { Some(v) -> use(v), None -> fallback }`

### String Concatenation
Python:    `greeting = "Hello, " + name + "!"`
Baseline:  `let greeting = "Hello, ${name}!"`

### Classes -> Records + Sum Types
Python:    `class User: def __init__(self, name, age): ...`
Baseline:  `type User = { name: String, age: Int }`

### Method Calls
Python:    `name.upper()`
Baseline:  `String.to_upper(name)`

### Boolean Negation
Python:    `if not valid:`
Baseline:  `if not valid then ...`

### HTTP Handler
Python:    `@app.get("/health") / def health(): return "ok"`
Baseline:  `fn health(req: Request) -> Result<Response, String> = Ok(Response.ok("healthy"))`

### Lambda / Anonymous Function
Python:    `lambda x: x + 1`
Baseline:  `|x| x + 1`

## Syntax

### Functions
```
fn add(a: Int, b: Int) -> Int = a + b
fn effectful!(x: Int) -> () = Console.println!("${x}")
```

### Effects
Effectful functions end with `!`. Effect annotations are optional — the compiler infers them:
```
fn fetch!(url: String) -> Result<String, String> = {
  Log.info!("Fetching ${url}")
  Http.get!(url)
}
```
Explicit annotations are allowed for documentation or to restrict effects:
```
fn fetch!(url: String) -> {Http, Log} Result<String, String> = ...
```
Pure functions (no `!`) cannot call effectful functions.

### Types
```
type Port = Int where self > 0 && self <= 65535    // Refinement type
type Status = | Active | Inactive | Error(String)  // Sum type (enum)
type User = { name: String, age: Int }             // Record type
type UserId = Int                                  // Type alias
type HasName = { name: String, ..r }               // Open record (row polymorphism)
```

### Built-in Types
`Int`, `Float`, `String`, `Bool`, `Unit`, `List<T>`, `Option<T>`, `Result<T, E>`, `Map<K, V>`, `Set<T>`, `Tuple`

### Let Bindings
```
let x = 42
let name: String = "Alice"
```

### Conditionals
```
if condition then expr1 else expr2
```

### Pattern Matching (exhaustive)
```
match value
  Some(x) -> x
  None -> 0

match status
  Active -> "active"
  Inactive -> "inactive"
  Error(msg) -> "error: ${msg}"
```

### Pipes and Lambdas
```
value |> transform |> validate    // |> inserts left as first arg
|x| x + 1                         // Lambda
|a, b| a + b
```

### Lists
```
let nums = [1, 2, 3]
List.map(nums, |x| x * 2)
List.filter(nums, |x| x > 1)
List.fold(nums, 0, |acc, x| acc + x)
```

### Records
```
let user = User { name: "Alice", age: 30 }
user.name                              // Field access
{ ..user, age: 31 }                   // Record update
```

### Row Polymorphism
```
fn greet(person: { name: String, ..r }) -> String = person.name
greet({ name: "Alice", age: 30 })      // OK — extra fields absorbed by ..r
greet({ name: "Bob" })                 // OK — exact match
```

### String Interpolation
```
"Hello, ${name}. You are ${age} years old."
```

### Error Handling
```
// Result: Ok(value) or Err(error)
let user = get_user(id)?               // Propagate with ?
match get_user(id)
  Ok(u) -> process(u)
  Err(e) -> handle(e)

// Option: Some(value) or None (sugar: T? means Option<T>)
```

### Inline Tests
```
fn add(a: Int, b: Int) -> Int = a + b

@test
test "basic" = add(1, 2) == 3
test "zero" = add(0, 5) == 5
```

### Modules
```
@prelude(script)                   // Prelude: core, pure, script, server
import Math                        // Qualified: Math.sqrt(9)
import Math { sqrt, pow }          // Selective
import Math *                      // Wildcard
```

### Logical Operators
`&&`, `||`, `not` (keyword, not `!`)

## Key Rules

1. Pure functions have NO `!` suffix and CANNOT use effects
2. Effectful functions end with `!` — effect annotations are optional (inferred by compiler)
3. Effects are called with `!`: `Console.println!("hello")`
4. Pattern matching must be exhaustive
5. `not` is a keyword for logical negation (not `!`)
6. String interpolation uses `${expr}`
7. Pipe `|>` inserts left value as first argument to right function

## NOT Supported

- No `class`/`extends`/`implements` — use records + sum types + effects
- No `try`/`catch`/`throw` — use `Result<T, E>` with `?`
- No `null`/`undefined`/`nil` — use `Option<T>`
- No `async`/`await` — effects handle this
- No `+` for string concat — use `"${a}${b}"`
- No `!` for boolean negation — use `not`
- No `value.method()` — use `Module.method(value)`
- No mutable variables, no `return` keyword, no semicolons
- No backward pipe `<|` or composition `>>`, `<<`

## Common Agent Mistakes

WRONG: `user.to_string()`   -> RIGHT: `String.from(user)` — no method calls on values
WRONG: `!valid`             -> RIGHT: `not valid` — `!` is for effects, `not` is for negation
WRONG: `"a" + "b"`          -> RIGHT: `"${a}${b}"` — no `+` for string concatenation
WRONG: `return x`           -> RIGHT: `x` — last expression is the return value
WRONG: `let mut x = 0`      -> RIGHT: restructure with recursion or `List.fold`
WRONG: `try { risky() }`    -> RIGHT: `match risky() { Ok(v) -> v, Err(e) -> handle(e) }`
WRONG: `async fn fetch()`   -> RIGHT: `fn fetch!()` — effects replace async/await
WRONG: `x; y; z`            -> RIGHT: `{ let _ = x  let _ = y  z }` — no semicolons
WRONG: `fn foo { ... }`     -> RIGHT: `fn foo() -> Type = expr` — signature required
WRONG: `import { foo }`     -> RIGHT: `import Foo { bar }` — module names are PascalCase

## Standard Library

### Core (`@prelude(core)`)
- **Int**: `to_string(Int) -> String`, `parse(String) -> Int`
- **Option**: `unwrap`, `unwrap_or`, `is_some`, `is_none`, `map`, `flat_map`
- **Result**: `unwrap`, `unwrap_or`, `is_ok`, `is_err`, `map`, `and_then`, `map_err`, `context`
- **Map**: `empty`, `insert`, `get`, `remove`, `contains`, `keys`, `values`, `len`, `from_list`
- **Set**: `empty`, `insert`, `remove`, `contains`, `union`, `intersection`, `len`, `from_list`

### Pure (`@prelude(pure)`) — adds data processing
- **List**: `length`, `head`, `tail`, `reverse`, `sort`, `concat`, `contains`, `get`, `map`, `filter`, `fold`, `find`
- **String**: `length`, `to_upper`, `to_lower`, `trim`, `contains`, `starts_with`, `ends_with`, `split`, `join`, `slice`, `chars`, `char_at`, `index_of`, `replace`, `to_int`, `char_code`, `from_char_code`
- **Math**: `abs`, `min`, `max`, `clamp`, `pow`
- **Crypto**: `sha256`, `hmac_sha256`, `constant_time_eq`
- **Json**: `parse`, `to_string`, `to_string_pretty`

### Script (`@prelude(script)`) — adds I/O and system
- **Console**: `println!`, `print!`, `error!`, `read_line!`
- **Fs**: `read!`, `write!`, `exists!`, `list_dir!`
- **Env**: `get!`, `set!`
- **Http**: `get!`, `post!`, `put!`, `delete!`, `request!`
- **Log**: `info!`, `warn!`, `error!`, `debug!`
- **Time**: `now!`, `sleep!`
- **DateTime**: `now!`, `parse`, `to_string`, `add`, `diff`
- **Random**: `int!`, `bool!`, `uuid!`

### Server (`@prelude(server)`) — adds web framework
- **Router**: `new`, `get`, `post`, `put`, `delete`, `patch`, `any`, `group`, `use`
- **Server**: `listen!`
- **Response**: `ok`, `json`, `created`, `no_content`, `bad_request`, `not_found`, `error`, `status`, `with_header`, `redirect`
- **Request**: `header`, `method`, `body_json`
- **Middleware**: `extract_bearer`, `extract_basic`, `cors_config`, `rate_limit_config`
- **HttpError**: `bad_request`, `not_found`, `unauthorized`, `forbidden`, `internal`, and more
- **Db**: `connect!`, `execute!`, `query!`, `require`, `optional`, `int_field`, `bool_field`, `first_row`, `has_rows`

## Common Patterns

```
// Effectful entry point
fn main!() =
  Console.println!("Hello, Baseline!")

// Data transformation pipeline
fn process(items: List<Int>) -> List<Int> =
  items
    |> List.filter(|x| x > 0)
    |> List.map(|x| x * 2)

// Error propagation
fn safe_divide(a: Int, b: Int) -> Result<Int, String> =
  if b == 0 then Err("Division by zero") else Ok(a / b)

// Sum type with pattern matching
type Shape = | Circle(Float) | Rectangle(Float, Float)

fn area(s: Shape) -> Float =
  match s
    Circle(r) -> 3.14159 * r * r
    Rectangle(w, h) -> w * h
```

## HTTP Server

```
@prelude(server)

fn health(req: Request) -> Result<Response, String> =
  Ok(Response.ok("healthy"))

fn main!() =
  Router.new()
    |> Router.get("/health", health)
    |> Server.listen!(8080)
```

## Database

```
@prelude(server)

fn main!() = {
  let db = Db.connect!("app.db")
  let _ = Db.execute!(db, "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)", [])
  let _ = Db.execute!(db, "INSERT INTO users (name) VALUES (?)", ["Alice"])
  let rows = Db.query!(db, "SELECT * FROM users", [])
  let _ = List.map(rows, |row| {
    let name = Db.require(row, "name")
    Console.println!("User: ${name}")
  })
}
```

## Preludes

| Level | Use Case | Includes |
|-------|----------|---------|
| `core` | Pure computation | Types, Option, Result, Map, Set |
| `pure` | Data processing | + String, List, Int, Math, Json, Crypto |
| `script` | CLI scripting | + Console, Env, Fs, Http, Log, Time, DateTime, Random |
| `server` | HTTP services | + Router, Server, Response, Request, Middleware, Db |

## Compiler
```
blc check file.bl           # Type/effect check
blc check file.bl --json    # JSON diagnostics
blc run file.bl             # Compile and run (VM)
blc test file.bl            # Run inline tests
blc test file.bl --json     # JSON test output
blc fmt file.bl             # Format source
```
