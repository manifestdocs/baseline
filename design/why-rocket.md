# Why Rocket: The Language the AI Web Needs

**A case for 1,000 developers who want to define the next decade of web infrastructure.**

---

## The Web Backend Is Broken in the Age of AI

Every day, millions of lines of backend code are generated by LLMs. And every day, that code ships with:

- **Validation bugs** because the AI forgot a boundary check on line 47
- **Security holes** because nothing stops generated code from calling `fs.delete()` inside a user-facing handler
- **Inconsistent patterns** because TypeScript has 6 ways to handle errors and the model picked a different one each time
- **Silent failures** because `null` snuck through 3 function calls before anyone noticed

These aren't AI problems. They're **language problems**. We've been asking machines to write code in languages designed for humans who debug with `console.log` and catch mistakes in code review. That era is ending.

---

## What If the Language Made Wrong Code Unwritable?

Not "hard to write." Not "flagged by a linter." **Unwritable.** As in: the compiler rejects it before it ever runs.

```rocket
// A function that handles user signups.
// Read this carefully. Then read what it CAN'T do.

handle_signup! : Request -> {Http, Db, Log} Response
handle_signup! = |req|
  let email = Email.parse(req.body.email)?    // Invalid email? Rejected at parse.
  let age = Age.parse(req.body.age)?          // Negative age? Type won't allow it.

  Log.info!("New signup: ${email}")
  let user = Db.insert!(User { email, age })

  Ok(Response.created(user))
```

What this function **cannot** do, enforced by the compiler:

| Forbidden action | Why it's impossible |
|---|---|
| Read from the filesystem | `Fs` is not in `{Http, Db, Log}` |
| Make arbitrary network calls | Only the declared `Http` effect is available |
| Process an invalid email | `Email` is a refinement type; invalid strings don't parse into it |
| Store a negative age | `Age` is `Int where self >= 0`; the type rejects it |
| Return without handling the error | `?` forces explicit propagation; unhandled `Result` is a compile error |
| Silently return null | `null` doesn't exist. `Option<T>` is explicit. |

This isn't defensive programming. This is **the language making the wrong program unrepresentable**.

---

## Why Now? Three Forces Converging

### 1. AI code generation is the default, not the exception

GitHub Copilot, Claude, Cursor, Windsurf -- developers don't write most of their code by hand anymore. But today's languages treat AI-generated code like human-written code: trusted by default, validated by hope.

Rocket treats AI-generated code as **untrusted by default, validated by proof.** The effect system is a capability sandbox. The type system is a correctness contract. The compiler is the reviewer that never gets tired.

### 2. WebAssembly is eating the server

Cloudflare Workers. Fastly Compute. Deno Deploy. Vercel Edge. Fermyon. Wasmer Edge. The next generation of web infrastructure runs WebAssembly, not Docker containers.

Rocket compiles to WASM natively. 1-3 MB binaries. Sub-10ms cold starts. No container images. No runtime dependencies. Deploy a Rocket web service the way you deploy a static file.

### 3. The type system revolution has arrived

Developers who grew up on TypeScript's type system are ready for more. Refinement types, algebraic effects, row polymorphism -- these aren't academic toys anymore. They're the tools that let you encode "this integer is a valid port number" or "this function can only read from the database" directly in the type system.

The research is mature. Koka proved effects work. Liquid Haskell proved refinements work. What's missing is a language that puts them together in a package optimized for web developers building APIs.

---

## The 1,000 Developer Thesis

New languages fail for one reason: ecosystem. Not design, not speed, not ergonomics. **Ecosystem.**

Rocket is designed to beat this problem through a strategy no previous language had access to:

### AI-Bootstrapped Ecosystem

Traditional language adoption:
```
Design language → Build compiler → Write stdlib → Write libraries →
Wait for adoption → Wait for more libraries → Reach critical mass (5-10 years)
```

Rocket's adoption path:
```
Design language → Build compiler → 1,000 developers write seed libraries →
AI translates 10,000 TypeScript/Rust packages → Compiler verifies translations →
Ecosystem bootstraps in months, not years
```

Here's why 1,000 committed developers is enough:

**The compiler is the multiplier.** When a developer writes a Rocket library, the compiler verifies it against its spec. When an AI translates a TypeScript library, the compiler verifies the translation. The verification is the same. The output quality is the same. One human writing specs and reviewing translations is equivalent to ten humans writing code by hand.

**The One Way Principle is the accelerant.** Because Rocket has one way to do everything, AI translation is dramatically more accurate. There's no ambiguity about which error handling pattern to use, which string formatting to pick, which loop construct to reach for. TypeScript-to-Rocket translation hits 80%+ accuracy on the first pass because the target is a narrow, well-defined corridor.

**The effect system is the trust layer.** Translated libraries declare their effects. A translated HTTP client that suddenly requires `Fs` access is immediately flagged. You don't need to audit 10,000 lines of translated code -- you read the effect signature and know exactly what it can do.

### What 1,000 Developers Actually Build

| Layer | What's needed | Estimated effort |
|---|---|---|
| **HTTP framework** | Router, middleware, request/response types | 5-10 developers |
| **Database** | Postgres, SQLite, MySQL drivers + query builder | 10-15 developers |
| **Auth** | JWT, OAuth2, session management | 5-10 developers |
| **Serialization** | JSON (built-in), MessagePack, Protocol Buffers | 5-10 developers |
| **Observability** | OpenTelemetry, structured logging, metrics | 5-10 developers |
| **Cloud SDKs** | AWS, GCP, Azure core services | 20-30 developers |
| **Common utilities** | UUID, datetime, crypto, validation | 10-15 developers |
| **Templates** | HTML templating, email templates | 5-10 developers |
| **Testing tools** | HTTP mocking, DB fixtures, snapshot testing | 5-10 developers |
| **CLI tooling** | Project scaffolding, deployment tools | 5-10 developers |
| **Documentation** | Guides, tutorials, examples, API docs | 20-30 developers |
| **AI translation** | TypeScript/Rust library translations + review | 50-100 developers |
| **Compiler contributions** | Bug fixes, optimizations, features | 50-100 developers |
| **Real applications** | Open-source apps that prove the language works | 100-200 developers |
| **Community** | Forums, Discord, blog posts, conference talks | Everyone |

That's a viable web ecosystem. Not comprehensive -- but enough to build real production APIs, which creates the gravity that pulls in the next 10,000 developers.

---

## The Developer Experience Pitch

### Write an API in 5 minutes

```rocket
@prelude(server)
module TodoApi

type Todo = {
  id: Int where self > 0,
  title: String where self.len > 0,
  done: Bool,
}

type CreateTodo = {
  title: String where self.len > 0,
}

// State: an in-memory list (swap for Db in production)
let todos: Ref<List<Todo>> = Ref.new([])

main! =
  let app = Router.new()
    |> Router.get("/todos", list_todos!)
    |> Router.post("/todos", create_todo!)
    |> Router.put("/todos/:id/done", mark_done!)

  Server.listen!(8080, app)

list_todos! : () -> {State} Response
list_todos! = ||
  let all = todos.get!()
  Ok(Response.json(all))

create_todo! : Request -> {State} Response
create_todo! = |req|
  let body = req.json::<CreateTodo>()?
  let id = todos.get!().len + 1
  let todo = Todo { id, title: body.title, done: false }
  todos.modify!(|list| [..list, todo])
  Ok(Response.created(todo))

mark_done! : Request -> {State} Response
mark_done! = |req|
  let id = req.param("id").parse::<Int>()?
  todos.modify!(|list|
    list.map(|t| if t.id == id then { ..t, done: true } else t)
  )
  Ok(Response.ok())
```

Notice what's absent: no `null`, no `try/catch`, no `undefined`, no type coercion surprises, no dependency injection framework, no decorator soup, no class hierarchies. Just types, functions, effects, and pipes.

### Test it without infrastructure

```rocket
describe "TodoApi" {
  let mock_state = State.mock([
    Todo { id: 1, title: "Buy milk", done: false },
  ])

  describe "list_todos" {
    it "returns all todos" {
      with { state: mock_state }
      given ()
      when list_todos
      expect Ok(Response { status: 200, .. })
    }
  }

  describe "create_todo" {
    context "with valid title" {
      it "creates a new todo" {
        with { state: mock_state }
        given Request.json({ title: "Write Rocket code" })
        when create_todo
        expect Ok(Response { status: 201, .. })
      }
    }

    context "with empty title" {
      it "rejects the request" {
        given Request.json({ title: "" })
        when create_todo
        expect Err(ValidationError { field: "title", .. })
      }
    }
  }
}
```

No test database. No Docker compose. No mocking library. Effects are swappable by design.

### Deploy to the edge

```bash
$ rocket build --wasm
  Compiled in 340ms
  Output: target/wasm/todo-api.wasm (1.2 MB)

$ wrangler deploy target/wasm/todo-api.wasm
  Deployed to 300+ edge locations worldwide
  Cold start: 4ms
```

Your API runs in every continent. Under 2 MB. Starting in milliseconds. No container registry. No Kubernetes. No load balancer configuration.

---

## What Rocket Is Not

Honest constraints, because developers respect honesty:

- **Not production-ready.** The specification is v0.1.0. There is no compiler yet. This is a call to build, not a call to adopt.
- **Not for every use case.** Rocket targets web APIs, backend services, and edge functions. It's not for game engines, embedded systems, or scientific computing.
- **Not backward-compatible.** Rocket deliberately breaks from existing language conventions when those conventions are wrong. No `null`. No classes. No exceptions. No implicit coercion.
- **Not a solo project.** No single person can build a language ecosystem. Rocket needs a community of developers who believe the AI-native web backend deserves a purpose-built language.

---

## The Bet

Here's the bet Rocket is making:

> **Within 3 years, more backend code will be generated by AI than written by humans. The languages that win will be the ones where AI-generated code is correct by construction, not correct by coincidence.**

TypeScript can't get there -- too many ways to do everything, no effect tracking, `any` as an escape hatch. Go can't get there -- no sum types, no generics (until recently), `if err != nil` repeated a billion times. Rust can't get there -- lifetime annotations are too complex for reliable AI generation. Python can't get there -- dynamic typing means errors surface at runtime, not compile time.

Rocket is designed from scratch for a world where:
- Code is **generated**, so syntax must be unambiguous
- Code is **untrusted**, so effects must be sandboxed
- Code is **verified**, so types must encode correctness
- Code is **deployed to the edge**, so binaries must be small and fast

The question isn't whether a language like this will exist. It's whether **we** build it, or wait for someone else to.

---

## Join

If you're one of the 1,000:

1. **Read the spec** -- `design/rocket-language-specification.md` is complete and detailed
2. **Pick a piece** -- Compiler frontend? Type checker? Effect system? Standard library? You choose.
3. **Build in public** -- Every contribution is visible, every decision is documented
4. **Ship something real** -- The goal isn't a perfect language. It's a language real developers use to build real web services.

The spec is written. The design is sound. The window is open.

Let's build.
