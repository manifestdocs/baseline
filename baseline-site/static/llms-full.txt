# Baseline v0.2

> Baseline is a strongly typed, effect-tracked functional programming language. Extension: `.bl`, compiler: `blc`. Design philosophy: "The type is the spec" (refinements encode correctness), "Effects are data" (side effects are explicit capabilities tracked by the compiler).

Important — LLMs commonly get these wrong:
- `!` means EFFECTS, not negation. Use `not` for boolean negation. `!valid` is a parse error.
- NO method syntax. Write `String.to_upper(name)`, never `name.to_upper()`.
- NO `+` for strings. Write `"Hello, ${name}!"`, never `"Hello, " + name`.
- NO semicolons. Statements are separated by newlines.
- NO `return` keyword. The last expression is the return value.
- All bindings are immutable. No `var`, no mutation, no reassignment.

## Rosetta Stone (Python -> Baseline)

### Variable Declaration
Python:    `x = 10`
Baseline:  `let x = 10`

### Function Definition
Python:    `def add(a: int, b: int) -> int: return a + b`
Baseline:  `fn add(a: Int, b: Int) -> Int = a + b`

### Side Effects (Print)
Python:    `print("hello")`
Baseline:  `Console.println!("hello")`

### List Operations
Python:    `[x * 2 for x in items if x > 0]`
Baseline:  `items |> List.filter(|x| x > 0) |> List.map(|x| x * 2)`

### Error Handling
Python:    `try: val = risky() / except: val = default`
Baseline:  `match risky() { Ok(v) -> v, Err(_) -> default }`

### Null Handling
Python:    `if x is not None: use(x)`
Baseline:  `match x { Some(v) -> use(v), None -> fallback }`

### String Concatenation
Python:    `greeting = "Hello, " + name + "!"`
Baseline:  `let greeting = "Hello, ${name}!"`

### Classes -> Records + Sum Types
Python:    `class User: def __init__(self, name, age): ...`
Baseline:  `type User = { name: String, age: Int }`

### Method Calls
Python:    `name.upper()`
Baseline:  `String.to_upper(name)`

### Boolean Negation
Python:    `if not valid:`
Baseline:  `if not valid then ...`

### HTTP Handler
Python:    `@app.get("/health") / def health(): return "ok"`
Baseline:  `fn health(req: Request) -> Result<Response, String> = Ok(Response.ok("healthy"))`

### Lambda / Anonymous Function
Python:    `lambda x: x + 1`
Baseline:  `|x| x + 1`

## Syntax

### Functions
```
fn add(a: Int, b: Int) -> Int = a + b
fn effectful!(x: Int) -> () = Console.println!("${x}")
```

### Effects
Effectful functions end with `!`. Effect annotations are optional — the compiler infers them:
```
fn fetch!(url: String) -> Result<String, String> = {
  Log.info!("Fetching ${url}")
  Http.get!(url)
}
```
Explicit annotations are allowed for documentation or to restrict effects:
```
fn fetch!(url: String) -> {Http, Log} Result<String, String> = ...
```
Pure functions (no `!`) cannot call effectful functions.

### Types
```
type Port = Int where self > 0 && self <= 65535    // Refinement type
type Status = | Active | Inactive | Error(String)  // Sum type (enum)
type User = { name: String, age: Int }             // Record type
type UserId = Int                                  // Type alias
type HasName = { name: String, ..r }               // Open record (row polymorphism)
```

### Built-in Types
`Int`, `Float`, `String`, `Bool`, `Unit`, `List<T>`, `Option<T>`, `Result<T, E>`, `Map<K, V>`, `Set<T>`, `Tuple`

### Let Bindings
```
let x = 42
let name: String = "Alice"
```

### Conditionals
```
if condition then expr1 else expr2
```

### Pattern Matching (exhaustive)
```
match value
  Some(x) -> x
  None -> 0

match status
  Active -> "active"
  Inactive -> "inactive"
  Error(msg) -> "error: ${msg}"
```

### Pipes and Lambdas
```
value |> transform |> validate    // |> inserts left as first arg
|x| x + 1                         // Lambda
|a, b| a + b
```

### Lists
```
let nums = [1, 2, 3]
List.map(nums, |x| x * 2)
List.filter(nums, |x| x > 1)
List.fold(nums, 0, |acc, x| acc + x)
```

### Records
```
let user = User { name: "Alice", age: 30 }
user.name                              // Field access
{ ..user, age: 31 }                   // Record update
```

### Row Polymorphism
```
fn greet(person: { name: String, ..r }) -> String = person.name
greet({ name: "Alice", age: 30 })      // OK — extra fields absorbed by ..r
greet({ name: "Bob" })                 // OK — exact match
```

### String Interpolation
```
"Hello, ${name}. You are ${age} years old."
```

### Error Handling
```
// Result: Ok(value) or Err(error)
let user = get_user(id)?               // Propagate with ?
match get_user(id)
  Ok(u) -> process(u)
  Err(e) -> handle(e)

// Option: Some(value) or None (sugar: T? means Option<T>)
```

### Inline Tests
```
fn add(a: Int, b: Int) -> Int = a + b

@test
test "basic" = add(1, 2) == 3
test "zero" = add(0, 5) == 5
```

### Modules
```
@prelude(script)                   // Prelude: core, pure, script, server
import Math                        // Qualified: Math.sqrt(9)
import Math { sqrt, pow }          // Selective
import Math *                      // Wildcard
```

### Logical Operators
`&&`, `||`, `not` (keyword, not `!`)

## Key Rules

1. Pure functions have NO `!` suffix and CANNOT use effects
2. Effectful functions end with `!` — effect annotations are optional (inferred by compiler)
3. Effects are called with `!`: `Console.println!("hello")`
4. Pattern matching must be exhaustive
5. `not` is a keyword for logical negation (not `!`)
6. String interpolation uses `${expr}`
7. Pipe `|>` inserts left value as first argument to right function

## NOT Supported

- No `class`/`extends`/`implements` — use records + sum types + effects
- No `try`/`catch`/`throw` — use `Result<T, E>` with `?`
- No `null`/`undefined`/`nil` — use `Option<T>`
- No `async`/`await` — effects handle this
- No `+` for string concat — use `"${a}${b}"`
- No `!` for boolean negation — use `not`
- No `value.method()` — use `Module.method(value)`
- No mutable variables, no `return` keyword, no semicolons
- No backward pipe `<|` or composition `>>`, `<<`

## Common Agent Mistakes

WRONG: `user.to_string()`   -> RIGHT: `String.from(user)` — no method calls on values
WRONG: `!valid`             -> RIGHT: `not valid` — `!` is for effects, `not` is for negation
WRONG: `"a" + "b"`          -> RIGHT: `"${a}${b}"` — no `+` for string concatenation
WRONG: `return x`           -> RIGHT: `x` — last expression is the return value
WRONG: `let mut x = 0`      -> RIGHT: restructure with recursion or `List.fold`
WRONG: `try { risky() }`    -> RIGHT: `match risky() { Ok(v) -> v, Err(e) -> handle(e) }`
WRONG: `async fn fetch()`   -> RIGHT: `fn fetch!()` — effects replace async/await
WRONG: `x; y; z`            -> RIGHT: `{ let _ = x  let _ = y  z }` — no semicolons
WRONG: `fn foo { ... }`     -> RIGHT: `fn foo() -> Type = expr` — signature required
WRONG: `import { foo }`     -> RIGHT: `import Foo { bar }` — module names are PascalCase

## Standard Library

### Core (`@prelude(core)`)
- **Int**: `to_string(Int) -> String`, `parse(String) -> Int`
- **Option**: `unwrap`, `unwrap_or`, `is_some`, `is_none`, `map`, `flat_map`
- **Result**: `unwrap`, `unwrap_or`, `is_ok`, `is_err`, `map`, `and_then`, `map_err`, `context`
- **Map**: `empty`, `insert`, `get`, `remove`, `contains`, `keys`, `values`, `len`, `from_list`
- **Set**: `empty`, `insert`, `remove`, `contains`, `union`, `intersection`, `len`, `from_list`

### Pure (`@prelude(pure)`) — adds data processing
- **List**: `length`, `head`, `tail`, `reverse`, `sort`, `concat`, `contains`, `get`, `map`, `filter`, `fold`, `find`
- **String**: `length`, `to_upper`, `to_lower`, `trim`, `contains`, `starts_with`, `ends_with`, `split`, `join`, `slice`, `chars`, `char_at`, `index_of`, `replace`, `to_int`, `char_code`, `from_char_code`
- **Math**: `abs`, `min`, `max`, `clamp`, `pow`
- **Crypto**: `sha256`, `hmac_sha256`, `constant_time_eq`
- **Json**: `parse`, `to_string`, `to_string_pretty`

### Script (`@prelude(script)`) — adds I/O and system
- **Console**: `println!`, `print!`, `error!`, `read_line!`
- **Fs**: `read!`, `write!`, `exists!`, `list_dir!`
- **Env**: `get!`, `set!`
- **Http**: `get!`, `post!`, `put!`, `delete!`, `request!`
- **Log**: `info!`, `warn!`, `error!`, `debug!`
- **Time**: `now!`, `sleep!`
- **DateTime**: `now!`, `parse`, `to_string`, `add`, `diff`
- **Random**: `int!`, `bool!`, `uuid!`

### Server (`@prelude(server)`) — adds web framework
- **Router**: `new`, `get`, `post`, `put`, `delete`, `patch`, `any`, `group`, `use`
- **Server**: `listen!`
- **Response**: `ok`, `json`, `created`, `no_content`, `bad_request`, `not_found`, `error`, `status`, `with_header`, `redirect`
- **Request**: `header`, `method`, `body_json`
- **Middleware**: `extract_bearer`, `extract_basic`, `cors_config`, `rate_limit_config`
- **HttpError**: `bad_request`, `not_found`, `unauthorized`, `forbidden`, `internal`, and more
- **Db**: `connect!`, `execute!`, `query!`, `require`, `optional`, `int_field`, `bool_field`, `first_row`, `has_rows`

## Standard Library Reference

Complete API for every module. Functions marked with `!` are effectful.

### Language

#### Console
Print output to the terminal, read user input, and write errors to stderr.

- `Console.println!(String) -> Unit` — Print a string to stdout followed by a newline.  
  Example: `Console.println!("Hello, world!")`
- `Console.print!(String) -> Unit` — Print a string to stdout without a trailing newline.  
  Example: `Console.print!("Enter name: ")`
- `Console.error!(String) -> Unit` — Print a string to stderr.  
  Example: `Console.error!("Something went wrong")`
- `Console.read_line!() -> String` — Read a line of input from stdin.  
  Example: `let name = Console.read_line!()`

#### Crypto
Hash data, compute HMACs, and perform constant-time comparisons.

- `Crypto.sha256(String) -> String` — Compute the SHA-256 hash of a string.  
  Example: `Crypto.sha256("hello")`
- `Crypto.hmac_sha256(String, String) -> String` — Compute an HMAC-SHA256 signature.  
  Example: `Crypto.hmac_sha256("secret", "message")`
- `Crypto.constant_time_eq(String, String) -> Bool` — Compare two strings in constant time to prevent timing attacks.  
  Example: `Crypto.constant_time_eq(provided, expected)`

#### DateTime
Parse, format, and manipulate dates and times.

- `DateTime.now!() -> <unknown>` — Return the current date and time as a DateTime record.  
  Example: `let now = DateTime.now!()`
- `DateTime.parse(String) -> <unknown>` — Parse a date string into a DateTime record.  
  Example: `DateTime.parse("2025-01-15T10:30:00Z")`
- `DateTime.to_string(<unknown>) -> String` — Format a DateTime as an ISO 8601 string.  
  Example: `DateTime.to_string(dt)`
- `DateTime.add(<unknown>, String, Int) -> <unknown>` — Add a duration to a DateTime.  
  Example: `DateTime.add(dt, "hours", 2)`
- `DateTime.diff(<unknown>, <unknown>, String) -> Int` — Calculate the difference between two DateTimes.  
  Example: `DateTime.diff(end, start, "seconds")`

#### Env
Read configuration from environment variables and set them for child processes.

- `Env.get!(String) -> Option<String>` — Read an environment variable, returning None if unset.  
  Example: `let port = Env.get!("PORT") |> Option.unwrap_or("3000")`
- `Env.set!(String, String) -> Unit` — Set an environment variable.  
  Example: `Env.set!("NODE_ENV", "production")`

#### Fs
Read files, write data to disk, and list directory contents.

- `Fs.read!(String) -> String` — Read a file's contents as a string.  
  Example: `let config = Fs.read!("config.json")`
- `Fs.write!(String, String) -> Unit` — Write a string to a file, creating or overwriting it.  
  Example: `Fs.write!("output.txt", "Hello!")`
- `Fs.exists!(String) -> Bool` — Check if a file path exists.
  Example:
  ```
  if Fs.exists!("config.json") then
    Fs.read!("config.json")
  else
    "{}"
  ```
- `Fs.read_file!(String) -> String` — Read a file's contents as a string.
- `Fs.write_file!(String, String) -> Unit` — Write a string to a file, creating or overwriting it.
- `Fs.list_dir!(String) -> List<String>` — List the entries in a directory.  
  Example: `Fs.list_dir!("./src")`
- `Fs.with_file!(String, (Scoped<String>) -> T) -> T` — Open a file, pass it to a callback, and close it automatically.

#### Http
Make HTTP requests to external APIs and fetch remote data.

- `Http.get!(String) -> <unknown>` — Send an HTTP GET request to a URL.  
  Example: `let resp = Http.get!("https://api.example.com/users")?`
- `Http.post!(String, String) -> <unknown>` — Send an HTTP POST request with a body.  
  Example: `Http.post!("https://api.example.com/users", body)?`
- `Http.put!(String, String) -> <unknown>` — Send an HTTP PUT request with a body.
- `Http.delete!(String) -> <unknown>` — Send an HTTP DELETE request to a URL.
- `Http.request!(<unknown>) -> <unknown>` — Send a custom HTTP request from a request record.

#### Int
Parse integers from strings and format numbers as text.

- `Int.to_string(Int) -> String` — Convert an integer to its string representation.  
  Example: `Int.to_string(42)  // => "42"`
- `Int.parse(String) -> Int` — Parse a string as an integer.  
  Example: `Int.parse("42")  // => 42`

#### Json
Decode JSON from APIs and encode your data structures back to JSON.

- `Json.parse(String) -> <unknown>` — Parse a JSON string into a value.  
  Example: `let data = Json.parse("{\"name\": \"Alice\"}")`
- `Json.to_string(<unknown>) -> String` — Serialize a value to a compact JSON string.
  Example:
  ```
  Json.to_string({ name: "Alice", age: 30 })
  // => "{\"name\":\"Alice\",\"age\":30}"
  ```
- `Json.to_string_pretty(<unknown>) -> String` — Serialize a value to a pretty-printed JSON string.  
  Example: `Json.to_string_pretty({ name: "Alice" })`

#### List
Transform collections with map and filter, reduce values with fold, and search for elements.

- `List.length(<unknown>) -> Int` — Return the number of elements in a list.  
  Example: `List.length([1, 2, 3])  // => 3`
- `List.head(List<T>) -> Option<T>` — Return the first element, or None if the list is empty.  
  Example: `List.head([1, 2, 3])  // => Some(1)`
- `List.tail(List<T>) -> List<T>` — Return all elements except the first.  
  Example: `List.tail([1, 2, 3])  // => [2, 3]`
- `List.reverse(List<T>) -> List<T>` — Return the list in reverse order.  
  Example: `List.reverse([1, 2, 3])  // => [3, 2, 1]`
- `List.sort(List<T>) -> List<T>` — Return the list sorted in ascending order.  
  Example: `List.sort([3, 1, 2])  // => [1, 2, 3]`
- `List.concat(List<T>, List<T>) -> List<T>` — Concatenate two lists.  
  Example: `List.concat([1, 2], [3, 4])  // => [1, 2, 3, 4]`
- `List.contains(<unknown>, <unknown>) -> Bool` — Check if a list contains a given element.  
  Example: `List.contains([1, 2, 3], 2)  // => true`
- `List.get(List<T>, Int) -> Option<T>` — Return the element at an index, or None if out of bounds.  
  Example: `List.get([10, 20, 30], 1)  // => Some(20)`
- `List.map(List<T>, (T) -> U) -> List<U>` — Apply a function to every element, returning a new list.
  Example:
  ```
  [1, 2, 3] |> List.map(|x| x * 2)
  // => [2, 4, 6]
  ```
- `List.filter(List<T>, (T) -> Bool) -> List<T>` — Return elements that satisfy a predicate.
  Example:
  ```
  [1, 2, 3, 4] |> List.filter(|x| x > 2)
  // => [3, 4]
  ```
- `List.fold(List<T>, U, (U, T) -> U) -> U` — Reduce a list to a single value using an accumulator function.
  Example:
  ```
  [1, 2, 3] |> List.fold(0, |acc, x| acc + x)
  // => 6
  ```
- `List.find(List<T>, (T) -> Bool) -> Option<T>` — Return the first element that satisfies a predicate, or None.
  Example:
  ```
  [1, 2, 3] |> List.find(|x| x > 1)
  // => Some(2)
  ```

#### Log
Record structured events at different severity levels for debugging and monitoring.

- `Log.info!(String) -> Unit` — Log a message at info level.  
  Example: `Log.info!("Server started on port 3000")`
- `Log.warn!(String) -> Unit` — Log a message at warning level.  
  Example: `Log.warn!("Cache miss for key: ${key}")`
- `Log.error!(String) -> Unit` — Log a message at error level.  
  Example: `Log.error!("Failed to connect: ${msg}")`
- `Log.debug!(String) -> Unit` — Log a message at debug level.  
  Example: `Log.debug!("Request payload: ${body}")`

#### Map
Store and retrieve values by key in immutable dictionaries.

- `Map.empty() -> Map<K, V>` — Create an empty map.
- `Map.insert(Map<K, V>, K, V) -> Map<K, V>` — Insert a key-value pair, returning a new map.
  Example:
  ```
  Map.empty()
  |> Map.insert("name", "Alice")
  |> Map.insert("age", "30")
  ```
- `Map.get(Map<K, V>, K) -> Option<V>` — Look up a key, returning Some(value) or None.  
  Example: `map |> Map.get("name")  // => Some("Alice")`
- `Map.remove(Map<K, V>, K) -> Map<K, V>` — Remove a key, returning a new map.  
  Example: `map |> Map.remove("age")`
- `Map.contains(Map<K, V>, K) -> Bool` — Check if a key exists in the map.  
  Example: `Map.contains(map, "name")  // => true`
- `Map.keys(Map<K, V>) -> List<K>` — Return all keys as a list.  
  Example: `Map.keys(map)  // => ["age", "name"]`
- `Map.values(Map<K, V>) -> List<V>` — Return all values as a list.  
  Example: `Map.values(map)  // => ["30", "Alice"]`
- `Map.len(Map<K, V>) -> Int` — Return the number of entries in the map.  
  Example: `Map.len(map)  // => 2`
- `Map.from_list(...)` — Create a map from a list of (key, value) pairs.  
  Example: `Map.from_list([("a", 1), ("b", 2)])`

#### Math
Perform common calculations like absolute value, min/max, and exponentiation.

- `Math.abs(Int) -> Int` — Return the absolute value of an integer.  
  Example: `Math.abs(-5)  // => 5`
- `Math.min(Int, Int) -> Int` — Return the smaller of two integers.  
  Example: `Math.min(3, 7)  // => 3`
- `Math.max(Int, Int) -> Int` — Return the larger of two integers.  
  Example: `Math.max(3, 7)  // => 7`
- `Math.clamp(Int, Int, Int) -> Int` — Constrain a value between a minimum and maximum.  
  Example: `Math.clamp(15, 0, 10)  // => 10`
- `Math.pow(Int, Int) -> Int` — Raise a base to an exponent.  
  Example: `Math.pow(2, 10)  // => 1024`

#### Option
Represent values that might be missing without using null.

- `Option.unwrap(Option<T>) -> T` — Extract the value from Some, or panic on None.  
  Example: `Some(42) |> Option.unwrap  // => 42`
- `Option.unwrap_or(Option<T>, T) -> T` — Extract the value from Some, or return a default.  
  Example: `None |> Option.unwrap_or(0)  // => 0`
- `Option.is_some(<unknown>) -> Bool` — Return true if the option contains a value.  
  Example: `Option.is_some(Some(1))  // => true`
- `Option.is_none(<unknown>) -> Bool` — Return true if the option is None.  
  Example: `Option.is_none(None)  // => true`
- `Option.map(Option<T>, (T) -> U) -> Option<U>` — Apply a function to the contained value, if present.
  Example:
  ```
  Some(5) |> Option.map(|x| x * 2)
  // => Some(10)
  ```
- `Option.flat_map(Option<T>, (T) -> Option<U>) -> Option<U>` — Apply a function that returns an Option, flattening the result.
  Example:
  ```
  Some(5) |> Option.flat_map(|x|
    if x > 0 then Some(x) else None
  )
  // => Some(5)
  ```

#### Random
Generate random numbers, booleans, and unique identifiers.

- `Random.int!(Int, Int) -> Int` — Generate a random integer between min and max (inclusive).  
  Example: `Random.int!(1, 100)`
- `Random.bool!() -> Bool` — Generate a random boolean.  
  Example: `if Random.bool!() then "heads" else "tails"`
- `Random.uuid!() -> String` — Generate a random UUID v4 string.  
  Example: `let id = Random.uuid!()`

#### Result
Handle operations that can fail with explicit error values instead of exceptions.

- `Result.unwrap(Result<T, E>) -> T` — Extract the Ok value, or panic on Err.  
  Example: `Ok(42) |> Result.unwrap  // => 42`
- `Result.unwrap_or(Result<T, E>, T) -> T` — Extract the Ok value, or return a default.  
  Example: `Err("fail") |> Result.unwrap_or(0)  // => 0`
- `Result.is_ok(<unknown>) -> Bool` — Return true if the result is Ok.  
  Example: `Result.is_ok(Ok(1))  // => true`
- `Result.is_err(<unknown>) -> Bool` — Return true if the result is Err.  
  Example: `Result.is_err(Err("fail"))  // => true`
- `Result.map(Result<T, ?2>, (T) -> E) -> Result<E, ?2>` — Apply a function to the Ok value, if present.
  Example:
  ```
  Ok(5) |> Result.map(|x| x * 2)
  // => Ok(10)
  ```
- `Result.and_then(Result<T, E>, (T) -> Result<U, E>) -> Result<U, E>` — Chain a function that returns a Result, flattening the result.
  Example:
  ```
  Ok(5) |> Result.and_then(|x|
    if x > 0 then Ok(x) else Err("negative")
  )
  // => Ok(5)
  ```
- `Result.map_err(Result<T, U>, (U) -> E) -> Result<T, E>` — Apply a function to the Err value, if present.
  Example:
  ```
  Err("fail") |> Result.map_err(|e| "wrapped: " ++ e)
  // => Err("wrapped: fail")
  ```
- `Result.context(Result<T, E>, String) -> Result<T, { context: String, error: ?1 }>` — Add context to an error, wrapping it in a record.
  Example:
  ```
  Err("db fail") |> Result.context("loading user")
  // => Err({ error: "db fail", context: "loading user" })
  ```

#### Set
Store unique elements and perform operations like union, intersection, and membership testing.

- `Set.empty() -> Set<T>` — Create an empty set.
- `Set.insert(Set<T>, T) -> Set<T>` — Add an element, returning a new set.  
  Example: `Set.empty() |> Set.insert(1) |> Set.insert(2)`
- `Set.remove(Set<T>, T) -> Set<T>` — Remove an element, returning a new set.
- `Set.contains(Set<T>, T) -> Bool` — Check if an element exists in the set.  
  Example: `Set.contains(s, 1)  // => true`
- `Set.union(Set<T>, Set<T>) -> Set<T>` — Return the union of two sets.
- `Set.intersection(Set<T>, Set<T>) -> Set<T>` — Return the intersection of two sets.
- `Set.len(Set<T>) -> Int` — Return the number of elements in the set.
- `Set.from_list(List<T>) -> Set<T>` — Create a set from a list of elements.  
  Example: `Set.from_list([1, 2, 3, 2])  // duplicates removed`

#### String
Split, trim, search, replace, and convert between strings and individual characters.

- `String.length(String) -> Int` — Return the number of characters in a string.  
  Example: `String.length("hello")  // => 5`
- `String.to_upper(String) -> String` — Convert all characters to uppercase.  
  Example: `String.to_upper("hello")  // => "HELLO"`
- `String.to_lower(String) -> String` — Convert all characters to lowercase.  
  Example: `String.to_lower("HELLO")  // => "hello"`
- `String.trim(String) -> String` — Remove leading and trailing whitespace.  
  Example: `String.trim("  hi  ")  // => "hi"`
- `String.contains(String, String) -> Bool` — Check if a string contains a substring.  
  Example: `String.contains("hello world", "world")  // => true`
- `String.starts_with(String, String) -> Bool` — Check if a string starts with a prefix.  
  Example: `String.starts_with("hello", "hel")  // => true`
- `String.ends_with(String, String) -> Bool` — Check if a string ends with a suffix.  
  Example: `String.ends_with("hello", "llo")  // => true`
- `String.split(String, String) -> List<String>` — Split a string by a delimiter into a list of strings.  
  Example: `"a,b,c" |> String.split(",")  // => ["a", "b", "c"]`
- `String.join(List<String>, String) -> String` — Join a list of strings with a separator.  
  Example: `["a", "b", "c"] |> String.join(", ")  // => "a, b, c"`
- `String.slice(String, Int, Int) -> String` — Extract a substring by start and end index.  
  Example: `String.slice("hello", 1, 4)  // => "ell"`
- `String.chars(String) -> List<String>` — Split a string into a list of single-character strings.  
  Example: `String.chars("hi")  // => ["h", "i"]`
- `String.char_at(String, Int) -> String` — Return the character at a given index.  
  Example: `String.char_at("hello", 0)  // => "h"`
- `String.index_of(String, String) -> Int` — Return the index of the first occurrence of a substring, or -1.  
  Example: `String.index_of("hello", "ll")  // => 2`
- `String.to_int(String) -> Int` — Parse a string as an integer.  
  Example: `String.to_int("42")  // => 42`
- `String.from_char_code(Int) -> String` — Create a single-character string from a Unicode code point.  
  Example: `String.from_char_code(65)  // => "A"`
- `String.char_code(String) -> Int` — Return the Unicode code point of the first character.  
  Example: `String.char_code("A")  // => 65`
- `String.replace(String, String, String) -> String` — Replace all occurrences of a pattern with a replacement.  
  Example: `String.replace("hello world", "world", "there")  // => "hello there"`

#### Time
Get the current timestamp and pause execution for a specified duration.

- `Time.now!() -> Int` — Return the current Unix timestamp in milliseconds.  
  Example: `let start = Time.now!()`
- `Time.sleep!(Int) -> Unit` — Pause execution for the given number of milliseconds.  
  Example: `Time.sleep!(1000)  // wait 1 second`

#### Weak
Break reference cycles with weak pointers that don't prevent garbage collection.

- `Weak.downgrade(T) -> Weak<T>` — Create a weak reference from a strong reference.
- `Weak.upgrade(Weak<T>) -> Option<T>` — Attempt to upgrade a weak reference to a strong one, returning an Option.

### Web Framework

#### HttpError
Create structured HTTP error values for use with error middleware.

- `HttpError.bad_request(String) -> <unknown>` — Create a 400 Bad Request error.  
  Example: `HttpError.bad_request("Invalid email")`
- `HttpError.not_found(String) -> <unknown>` — Create a 404 Not Found error.  
  Example: `HttpError.not_found("User not found")`
- `HttpError.unauthorized(String) -> <unknown>` — Create a 401 Unauthorized error.
- `HttpError.forbidden(String) -> <unknown>` — Create a 403 Forbidden error.
- `HttpError.conflict(String) -> <unknown>` — Create a 409 Conflict error.
- `HttpError.unprocessable(String) -> <unknown>` — Create a 422 Unprocessable Entity error.
- `HttpError.internal(String) -> <unknown>` — Create a 500 Internal Server Error.
- `HttpError.method_not_allowed(String) -> <unknown>` — Create a 405 Method Not Allowed error.
- `HttpError.too_many_requests(String) -> <unknown>` — Create a 429 Too Many Requests error.
- `HttpError.bad_gateway(String) -> <unknown>` — Create a 502 Bad Gateway error.
- `HttpError.service_unavailable(String) -> <unknown>` — Create a 503 Service Unavailable error.
- `HttpError.gateway_timeout(String) -> <unknown>` — Create a 504 Gateway Timeout error.

#### Middleware
Extract authentication credentials, configure CORS, and set up rate limiting.

- `Middleware.extract_bearer(<unknown>) -> <unknown>` — Extract a Bearer token from the Authorization header.  
  Example: `let token = Middleware.extract_bearer(req)`
- `Middleware.extract_basic(<unknown>) -> <unknown>` — Extract Basic auth credentials from the Authorization header.  
  Example: `let creds = Middleware.extract_basic(req)`
- `Middleware.cors_config() -> <unknown>` — Create a CORS configuration record.
- `Middleware.rate_limit_config() -> <unknown>` — Create a rate limiting configuration record.

#### Request
Extract HTTP method, headers, body, and attached state from incoming requests.

- `Request.header(<unknown>, String) -> <unknown>` — Read a header value from the request.  
  Example: `let token = Request.header(req, "Authorization")`
- `Request.method(<unknown>) -> String` — Return the HTTP method of the request.  
  Example: `let method = Request.method(req)`
- `Request.body_json(<unknown>) -> <unknown>` — Parse the request body as JSON.  
  Example: `let data = Request.body_json(req)`

#### Response
Build HTTP responses with custom status codes, headers, and JSON or text bodies.

- `Response.ok(String) -> <unknown>` — Create a 200 OK response with a text body.  
  Example: `Response.ok("Hello!")`
- `Response.json(<unknown>) -> <unknown>` — Create a 200 OK response with a JSON body.  
  Example: `Response.json({ users: users, count: List.length(users) })`
- `Response.created(String) -> <unknown>` — Create a 201 Created response with a text body.  
  Example: `Response.created(user)`
- `Response.no_content() -> <unknown>` — Create a 204 No Content response.  
  Example: `Response.no_content()`
- `Response.bad_request(String) -> <unknown>` — Create a 400 Bad Request response.  
  Example: `Response.bad_request("Missing required field: name")`
- `Response.not_found(String) -> <unknown>` — Create a 404 Not Found response.  
  Example: `Response.not_found("User not found")`
- `Response.error(String) -> <unknown>` — Create a 500 Internal Server Error response.  
  Example: `Response.error("Internal error")`
- `Response.status(Int, String) -> <unknown>` — Create a response with a custom status code and body.  
  Example: `Response.status(429, "Rate limit exceeded")`
- `Response.with_header(<unknown>, String, String) -> <unknown>` — Add a single header to a response.
  Example:
  ```
  Response.ok("hi")
  |> Response.with_header("X-Request-Id", id)
  ```
- `Response.with_headers(<unknown>, <unknown>) -> <unknown>` — Add multiple headers to a response.
- `Response.redirect(String) -> <unknown>` — Create a 302 temporary redirect to a URL.  
  Example: `Response.redirect("/login")`
- `Response.redirect_permanent(String) -> <unknown>` — Create a 301 permanent redirect to a URL.

#### Router
Define URL patterns, register handlers for HTTP methods, and organize routes into groups.

- `Router.new() -> <unknown>` — Create a new empty router.  
  Example: `let app = Router.new()`
- `Router.routes(<unknown>) -> <unknown>` — Return the configured route table.
- `Router.get(<unknown>, String, <unknown>) -> <unknown>` — Register a handler for GET requests at a path.
  Example:
  ```
  Router.new()
  |> Router.get("/hello", |req| Response.ok("Hello!"))
  ```
- `Router.post(<unknown>, String, <unknown>) -> <unknown>` — Register a handler for POST requests at a path.  
  Example: `router |> Router.post("/users", create_user)`
- `Router.put(<unknown>, String, <unknown>) -> <unknown>` — Register a handler for PUT requests at a path.
- `Router.delete(<unknown>, String, <unknown>) -> <unknown>` — Register a handler for DELETE requests at a path.
- `Router.patch(<unknown>, String, <unknown>) -> <unknown>` — Register a handler for PATCH requests at a path.
- `Router.options(<unknown>, String, <unknown>) -> <unknown>` — Register a handler for OPTIONS requests at a path.
- `Router.head(<unknown>, String, <unknown>) -> <unknown>` — Register a handler for HEAD requests at a path.
- `Router.any(<unknown>, String, <unknown>) -> <unknown>` — Register a handler for all HTTP methods at a path.
- `Router.use(<unknown>, <unknown>) -> <unknown>` — Add middleware to the router.  
  Example: `router |> Router.use(auth_middleware)`
- `Router.group(<unknown>, String, <unknown>) -> <unknown>` — Group routes under a shared path prefix.
  Example:
  ```
  router |> Router.group("/api", |r|
    r |> Router.get("/users", list_users)
      |> Router.post("/users", create_user)
  )
  ```

#### Server
Start an HTTP server listening on a specific port.

- `Server.listen!(<unknown>, Int) -> Unit` — Start the HTTP server on the given port.
  Example:
  ```
  let app = Router.new()
    |> Router.get("/", |req| Response.ok("Hello!"))
  
  Server.listen!(app, 3000)
  ```

### Database

#### Db
Connect to SQLite, run queries, and parse result rows into typed values.

- `Db.connect!(String) -> <unknown>` — Open a connection to a SQLite database.  
  Example: `let db = Db.connect!("app.db")`
- `Db.execute!(<unknown>, String, <unknown>) -> <unknown>` — Execute a SQL statement with parameter binding.  
  Example: `Db.execute!(db, "INSERT INTO users (name) VALUES (?)", [name])`
- `Db.query!(<unknown>, String, <unknown>) -> <unknown>` — Run a SQL query and return matching rows.  
  Example: `let users = Db.query!(db, "SELECT * FROM users WHERE active = ?", [1])`
- `Db.require(Map<String, String>, String) -> String` — Get a required string field from a row. Returns "" if the key is missing.  
  Example: `let name = Db.require(row, "name")`
- `Db.optional(Map<String, String>, String) -> Option<String>` — Get an optional string field. Returns None if the key is missing or the value is empty.  
  Example: `let email = Db.optional(row, "email")`
- `Db.int_field(Map<String, String>, String) -> Int` — Parse an integer field from a row. Returns 0 if the key is missing or unparseable.  
  Example: `let age = Db.int_field(row, "age")`
- `Db.bool_field(Map<String, String>, String) -> Bool` — Parse a boolean field from a row. Returns true only if the value is "1".  
  Example: `let active = Db.bool_field(row, "active")`
- `Db.first_row(List<Map<String, String>>) -> Option<Map<String, String>>` — Return the first row from a query result, or None if empty.  
  Example: `let user = Db.first_row(Db.query!(db, "SELECT * FROM users WHERE id = ?", [id]))`
- `Db.has_rows(List<Map<String, String>>) -> Bool` — Check whether a query result contains any rows.  
  Example: `let exists = Db.has_rows(Db.query!(db, "SELECT 1 FROM users WHERE email = ?", [email]))`

## Common Patterns

```
// Effectful entry point
fn main!() =
  Console.println!("Hello, Baseline!")

// Data transformation pipeline
fn process(items: List<Int>) -> List<Int> =
  items
    |> List.filter(|x| x > 0)
    |> List.map(|x| x * 2)

// Error propagation
fn safe_divide(a: Int, b: Int) -> Result<Int, String> =
  if b == 0 then Err("Division by zero") else Ok(a / b)

// Sum type with pattern matching
type Shape = | Circle(Float) | Rectangle(Float, Float)

fn area(s: Shape) -> Float =
  match s
    Circle(r) -> 3.14159 * r * r
    Rectangle(w, h) -> w * h
```

## HTTP Server

```
@prelude(server)

fn health(req: Request) -> Result<Response, String> =
  Ok(Response.ok("healthy"))

fn main!() =
  Router.new()
    |> Router.get("/health", health)
    |> Server.listen!(8080)
```

## Database

```
@prelude(server)

fn main!() = {
  let db = Db.connect!("app.db")
  let _ = Db.execute!(db, "CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)", [])
  let _ = Db.execute!(db, "INSERT INTO users (name) VALUES (?)", ["Alice"])
  let rows = Db.query!(db, "SELECT * FROM users", [])
  let _ = List.map(rows, |row| {
    let name = Db.require(row, "name")
    Console.println!("User: ${name}")
  })
}
```

## Preludes

| Level | Use Case | Includes |
|-------|----------|---------|
| `core` | Pure computation | Types, Option, Result, Map, Set |
| `pure` | Data processing | + String, List, Int, Math, Json, Crypto |
| `script` | CLI scripting | + Console, Env, Fs, Http, Log, Time, DateTime, Random |
| `server` | HTTP services | + Router, Server, Response, Request, Middleware, Db |

## Compiler
```
blc check file.bl           # Type/effect check
blc check file.bl --json    # JSON diagnostics
blc run file.bl             # Compile and run (VM)
blc test file.bl            # Run inline tests
blc test file.bl --json     # JSON test output
blc fmt file.bl             # Format source
```
